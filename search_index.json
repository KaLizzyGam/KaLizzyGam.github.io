[["index.html", "Introducción a Ciencia de Datos con R (Tidyverse) Capítulo 1 BIENVENIDA 1.1 Objetivo 1.2 ¿Quienes somos? 1.3 Ciencia de Datos en R 1.4 Estructura del curso actual 1.5 Duración y evaluación del curso 1.6 Recursos y dinámica de clase", " Introducción a Ciencia de Datos con R (Tidyverse) Karina Lizette Gamboa Puente Oscar Arturo Bringas López Capítulo 1 BIENVENIDA 1.1 Objetivo Brindar al participante los elementos teóricos y prácticos básicos alrededor de la Ciencia de Datos. Aprenderá a distinguir las diferentes soluciones a problemas que pueden resolverse con algoritmos de machine learning y aprenderá a usar el conjunto de librerías en R más novedoso, estructurado y ampliamente usado para la manipulación, transformación y visualización de datos: “TIDYVERSE”. 1.2 ¿Quienes somos? ACT. ARTURO BRINGAS LinkedIn Email: act.arturo.b@ciencias.unam.mx Actuario, egresado de la Facultad de Ciencias y Maestría en Ciencia de Datos, ITAM. Experiencia en modelos predictivos y de clasificación de machine learning aplicado a seguros, deportes y movilidad internacional. Jefe de departamento en Investigación Aplicada y Opinión de la UNAM, donde realiza estudios estadísticos de percepción social. Consultor para empresas y organizaciones como UNODC, GNP, CBX, El Universal, INEGI, UNAM, IZZI. Actualmente se desempeña en diferentes proyectos en consultorías como Sinnia, Geek-end y DDI contribuyendo a empresas en temas de ciencia de datos, estadística, visualización de datos y análisis geoespacial. ACT. LIZETTE GAMBOA LinkedIn Email: lizzygamboa@ciencias.unam.mx Actuaria, egresada de la Facultad de Ciencias, UNAM, Maestría en Ciencia de Datos, ITAM. Experiencia en áreas de analítica predictiva e inteligencia del negocio. Lead y Senior Data Scientist en consultoría en diferentes proyectos con empresas de tecnología, retail y del sector asegurador, financiero y bancario. Experta en entendimiento de negocio para la correcta implementación de algoritmos de inteligencia y explotación de datos. Actualmente se desarrolla como Analytics Architect en Merama, Senior Data Science en CLOSTER y profesora de cursos de ciencia de datos en AMAT. Empresas anteriores: GNP, Activer Banco y Casa de Bolsa, PlayCity Casinos, RakenDataGroup Consulting, entre otros. 1.3 Ciencia de Datos en R 1.4 Estructura del curso actual 1.4.1 Alcances del curso Al finalizar este curso el participante será capaz de consumir, manipular y visualizar información proveniente de diversas fuentes de información para resolver problemas de propósito general asociados a los datos. Este curso brindará las bases para introducirse a cualquiera de los cursos de Ciencia de datos que se imparten en AMAT: Data Science &amp; Machine Learning (Aprendizaje supervisado I) Data Science &amp; Machine Learning (Aprendizaje no supervisado) Requisitos: Computadora con al menos 4Gb Ram Temario: 1. Introducción a Ciencia de Datos ¿Qué es Ciencia de Datos? Objetivo de la ciencia de datos ¿Qué se requiere para hacer ciencia de datos? Tipos de problemas que se pueden resolver Tipos de algoritmos y aprendizaje 2. Transformación y manipulación de estructuras de datos Importación Lectura Consultas Transformación de estructura 3. Manipulación de texto Concatenación Expresiones regulares Extracción 4. Manipulación de fechas y horas Creación de datos temporales Transformación de datos temporales Operaciones con datos temporales 5. Análisis exploratorio y visualización interactiva de datos EDA GEDA Uso, decisión e implementación de técnicas gráficas Visualización interactiva 1.5 Duración y evaluación del curso El programa tiene una duración de 24 hrs. Las clases serán impartidas los días sábado, de 9:00 am a 1:00 pm Serán asignados ejercicios que el participante deberá resolver entre una semana y otra. Al final del curso se solicitará un proyecto final, el cual deberá ser entregado para ser acreedor a la constancia de participación. 1.6 Recursos y dinámica de clase En esta clase estaremos usando: R da click aquí si aún no lo descargas RStudio da click aquí también Miro úsame Zoom Clases Pulgar arriba: Voy bien, estoy entendiendo! Pulgar abajo: Eso no quedó muy claro Mano arriba: Quiero participar/preguntar ó Ya estoy listo para iniciar Grupo de WhatsApp El chismecito está aquí Posible Drive Aún no hay documentos, no seas avorazado :D Notas de clase Revisame si quieres aprender "],["introducción-a-ciencia-de-datos.html", "Capítulo 2 Introducción a Ciencia de Datos 2.1 ¿Qué es Ciencia de Datos? 2.2 Objetivo de la Ciencia de Datos 2.3 ¿Qué se requiere para hacer Ciencia de Datos? 2.4 Aplicaciones de Ciencia de Datos 2.5 Tipos de aprendizaje 2.6 ¿Qué es R? 2.7 ¿Cómo obtener R? 2.8 ¿Qué es RStudio? 2.9 R como lenguaje orientado a objetos", " Capítulo 2 Introducción a Ciencia de Datos 2.1 ¿Qué es Ciencia de Datos? 2.1.1 Definiendo conceptos: Estadistica Disciplina que recolecta, organiza, analiza e interpreta datos. Lo hace a través de una población muestral generando estadística descriptiva y estadística inferencial. Estadística descriptiva: Describe de manera cuantificada información de los datos: distribuciones de los datos, análisis exploratorio, correlaciones, outliers, etc. Estadística inferencial: A partir de los datos de una población muestral, deducir / concluir / analizar hipótesis para una población. Principales tipos de problemas: Todo lo que tenga datos - tener muchos datos, puede llegar a ser un problema -. La estadística supone casi siempre que el sistema es estático y generaliza la solución bajo las mismas condiciones. Si la cantidad de datos es de “gran escala,” es muy probable que se tengan que hacer muestras para trabajar con los datos. Business Intelligence: BI aprovecha el software y los servicios para transformar los datos en conocimientos prácticos que informan las decisiones empresariales estratégicas y tácticas de una organización. Las herramientas de BI acceden y analizan conjuntos de datos y presentan hallazgos analíticos en informes, resúmenes, tableros, gráficos, cuadros, -indicadores- o KPI’s y mapas para proporcionar a los usuarios inteligencia detallada sobre el estado del negocio. (BI esta enfocado en analizar la historia pasada) Machine Learning: El ‘machine learning’ –aprendizaje automático– es una rama de la inteligencia artificial que permite que las máquinas aprendan de los patrones existentes en los datos. Se usan métodos computacionales para aprender de datos con el fin de producir reglas para mejorar el desempeño en alguna tarea o toma de decisión. (Está enfocado en la programación de máquinas para aprender de los patrones existentes en datos principalmente estructurados y anticiparse al futuro) Deep Learning: El aprendizaje profundo es un subcampo del aprendizaje automático que se ocupa de los algoritmos inspirados en la estructura y función del cerebro llamados redes neuronales artificiales. En Deep Learning, un modelo de computadora aprende a realizar tareas de clasificación directamente a partir de imágenes, texto o sonido. Los modelos de aprendizaje profundo pueden lograr una precisión de vanguardia, a veces superando el rendimiento a nivel humano. Los modelos se entrenan mediante el uso de un gran conjunto de datos etiquetados y arquitecturas de redes neuronales que contienen muchas capas. (Está enfocado en la programación de máquinas para el reconocimiento de imagenes y audio (datos no estructurados)) Big data se refiere a los grandes y diversos conjuntos de información que crecen a un ritmo cada vez mayor. Abarca el volumen de información, la velocidad a la que se crea y recopila, y la variedad o alcance de los puntos de datos que se cubren. Los macrodatos a menudo provienen de la minería de datos y llegan en múltiples formatos. Es comun que se confunda los conceptos de Big Data y Big Compute, como habiamos mencionado Big Data se refiere a el procesamiento de conjuntos de datos que son más voluminosos y complejos que los tradicionales y Big Compute a herramientas y enfoques que utilizan una gran cantidad de recursos de CPU y memoria de forma coordinada para resolver problemas que usan algoritmos muy complejos. Curiosidad: Servidores en líquido para ser enfriados Curiosidad 2: Centro de datos en el océano Entonces, ¿qué NO es ciencia de datos? No es una tecnología No es una herramienta No es desarrollo de software No es Business Intelligence* No es Big Data* No es Inteligencia Artificial* No es (solo) machine learning No es (solo) deep learning No es (solo) visualización No es (solo) hacer modelos 2.2 Objetivo de la Ciencia de Datos Ciencia de datos: Los científicos de datos analizan qué preguntas necesitan respuesta y dónde encontrar los datos relacionados. Tienen conocimiento de negocio y habilidades analíticas, así como la capacidad de extraer, limpiar y presentar datos. Las empresas utilizan científicos de datos para obtener, administrar y analizar grandes cantidades de datos no estructurados. Luego, los resultados se sintetizan y comunican a las partes interesadas clave para impulsar la toma de decisiones estratégicas en la organización. Fuente: Blog post de Drew Conway Más sobre Conway: Forbes 2016 2.3 ¿Qué se requiere para hacer Ciencia de Datos? Background científico Conocimientos generales de probabilidad, estadística, álgebra lineal, cálculo, geometría análitica, programación, conocimientos computacionales… etc Datos Relevancia y suficiencia Es indispensable saber si los datos con los que se trabajará son relevantes y suficientes, debemos evaluar qué preguntas podemos responder con los datos con los que contamos. Suficiencia: Los datos con los que trabajamos tienen que ser representativos de la población en general, necesitamos que las características representadas en la información sean suficientes para aproximar a la población objetivo. Relevancia: De igual manera los datos tienen que tener relevancia para la tarea que queremos resolver, por ejemplo, es probable que información sobre gusto en alimentos sea irrelevante para predecir número de hijos. Etiquetas Se necesita la intervención humana para etiquetar, clasificar e introducir los datos en el algoritmo. Software Existen distintos lenguajes de programación para realizar ciencia de datos: 2.4 Aplicaciones de Ciencia de Datos Dependiendo de la industria en la que se quiera aplicar Machine Learning, podemos pensar en distintos enfoques, en la siguiente imagen se muestran algunos ejemplos: Podemos pensar en una infinidad de aplicaciones comerciales basadas en el análisis de datos. Con la intención de estructurar las posibles aplicaciones, se ofrece a contiuación una categorización que, aunque no es suficiente para englobar todos los posibles casos de uso, sí es sorprendente la cantidad de aplicaciones que abarca. 1. Aplicaciones centradas en los clientes Incrementar beneficio al mejorar recomendaciones de productos Upselling Cross-selling Reducir tasas de cancelación y mejorar tasas de retención Personalizar experiencia de usuario Mejorar el marketing dirigido Análisis de sentimientos Personalización de productos o servicios 2. Optimización de problemas Optimización de precios Ubicación de nuevas sucursales Maximización de ganancias mediante producción de materias primas Construcción de portafolios de inversión 3. Predicción de demanda Número futuro de clientes Número esperado de viajes en avión / camión / bicis Número de contagios por un virus (demanda médica / medicamentos / etc) Predicción de uso de recursos (luz / agua / gas) 4. Análisis de detección de fraudes Detección de robo de identidad Detección de transacciones ilícitas Detección de servicios fraudulentos Detección de zonas geográficas con actividades ilícitas 2.5 Tipos de aprendizaje La diferencia entre el análisis supervisado y el no supervisado es la etiqueta, es decir, en el análisis supervisado tenemos una etiqueta “correcta” y el objetivo de los algoritmos es predecir esta etiqueta. 2.5.1 Aprendizaje supervisado Conocemos la respuesta correcta de antemano. Esta respuesta correcta fue “etiquetada” por un humano (la mayoría de las veces, en algunas circunstancias puede ser generada por otro algoritmo). Debido a que conocemos la respuesta correcta, existen muchas métricas de desempeño del modelo para verificar que nuestro algoritmo está haciendo las cosas “bien.” 2.5.1.1 Tipos de aprendizaje supervisado (Regresión vs clasificación) Existen dos tipos principales de aprendizaje supervisado, esto depende del tipo de la variable respuesta: Los algoritmos de clasificación se usan cuando el resultado deseado es una etiqueta discreta, es decir, clasifican un elemento dentro de diversas clases. En un problema de regresión, la variable target o variable a predecir es un valor numérico. 2.5.2 Aprendizaje no supervisado Aquí no tenemos la respuesta correcta de antemano ¿cómo podemos saber que el algoritmo está bien o mal? Estadísticamente podemos verificar que el algoritmo está bien Siempre tenemos que verificar con el cliente si los resultados que estamos obteniendo tienen sentido de negocio. Por ejemplo, número de grupos y características 2.6 ¿Qué es R? R (R Core Team 2018) es un entorno y lenguaje de programación que permite el análisis estadístico de información y reportes gráficos. Es ampliamente usado en investigación por la comunidad estadística en campos como la biomedicina, minería de datos, matemáticas financieras, entre otros. Ha ganado mucha popularidad en los últimos años al ser un software libre que está en constante crecimiento por las aportaciones de otros usuarios y que permite la interacción con software estadísticos como STATA, SAS, SPSS, etc.. R permite la incorporación de librerías y paqueterías con funcionalidades específicas, por lo que es un lenguaje de programación muy completo y fácil de usar. 2.7 ¿Cómo obtener R? R puede ser fácilmente descargado de forma gratuita desde el sitio oficial http://www.r-project.org/. R está disponible para las plataformas Windows, Mac y Linux. 2.8 ¿Qué es RStudio? RStudio es un Entorno de Desarrollo Integrado (IDE, por sus siglas en inglés) para R. Este permite y facilita el desarrollo y ejecución de sintaxis para código en R, incluye una consola y proporciona herramientas para la gestión del espacio de trabajo. RStudio está disponible para Windows, Mac y Linux o para navegadores conectados a RStudio Server o RStudio Server Pro. Algunas de las principales características de Rstudio que lo hacen una gran herramienta para trabajar en R, son: Auto completado de código Sangría inteligente Resaltado de sintaxis Facilidad para definir funciones Soporte integrado Documentación integrada Administración de directorios y proyectos Visor de datos Depurador interactivo para corregir errores Conección con Rmarkwon y Sweave La siguiente imagen muestra la forma en la que está estructurado RStudio. El orden de los páneles puede ser elegido por el usuario, así como las características de tipo de letra, tamaño y color de fondo, entre otras características. Figure 2.1: Páneles de trabajo de Rstudio 2.9 R como lenguaje orientado a objetos R es un lenguaje de programación orientado a objetos (POO). (López 2011, pag. 5) define a los objetos y sus características como “cualquier cosa con significado para el problema que se trata de resolver.” A partir de esa definición, se puede decir que sirve para representar alguna entidad de la vida real, por lo general son componentes del problema que se pretende resolver y con los que podemos interactuar. A través de esta interacción y del estudio que se haga de ellos, es posible clasificarlos en grupos de acuerdo a sus caractrerísticas. A partir de los objetos con los que se trabaje, surgirán las clases adecuadas para encontrar la solución a un problema dado. Los objetos tienen características fundamentales que permiten identificarlos, conocerlos y entender su comportamiento. De acuerdo con (Schildt 2009), estas características son: Identidad Comportamiento Estructura Identidad: Esta es la propiedad que da nombre a cada uno de los objetos y que permite declararlos, distinguirlos de manera única, usarlos y llamarlos para la representación de su contenido. Comportamiento: Esta es la propiedad que determina las operaciones que puede realizar el objeto, es decir, permite conocer las capacidades y alcances de la funcionalidad de cada objeto. El comportamiento permite conocer la interacción que puede existir con otros objetos y los resultrados que generarán. Estructura: El estado se refiere a un conjunto de características o atributos específicos del objeto dados en un momento determinado, y que pueden cambiar en un instante de tiempo. En la programación orientada a objetos, un programa recolecta muchos objetos para ser tratado como un conjunto dinámico de objetos interactuando entre sí. Los objetos están definidos por: Atributos: Son las propiedades o características de los datos contenidos en un objeto. Los valores asociados a un objeto en un momento determinado del tiempo determinan su estado. Métodos: Acceden a los atributos de los objetos y determinan el comportamiento de los datos contenidos. 2.9.1 Clases R posee 5 clases de objetos básicas o atómicas integradas. A partir de la combinación de ellas, se construyen todas las demás. Estas clases atómicas son: Character (caracteres) Numeric (números reales) Integer (números enteros) Complex (números complejos) Logical (valores lógicos verdadero y falso) En R, todo es un objeto, por lo que es posible acceder a sus características a través de funciones predefinidas en la librería básica. Por ejemplo: class(&quot;Hola mundo&quot;) ## [1] &quot;character&quot; class(10.5) ## [1] &quot;numeric&quot; class(integer(10)) ## [1] &quot;integer&quot; class(10 + 1i) ## [1] &quot;complex&quot; class(TRUE) ## [1] &quot;logical&quot; 2.9.2 Creación de objetos Los objetos pueden ser guardados a través del operador ‘&lt;-’ ó ‘=,’ anteponiendo al operador un nombre que servirá como el identificador del objeto: Mi_primer_objeto &lt;- 10 Nombre_identificador &lt;- &quot;Objeto de clase caracter&quot; Es posible acceder al contenido de un objeto al mandarlo llamar mediante su identificador, esto se logra escribiendo en la consola la función ‘print(),’ incluyendo entre paréntesis el nombre del objeto a imprimir, o bien, escribiendo en la consola directamente el nombre del objeto y automáticamente imprimirá su contenido, como se ve a continuación: print(Mi_primer_objeto) ## [1] 10 Nombre_identificador ## [1] &quot;Objeto de clase caracter&quot; Para almacenar conjuntos de datos en R, es posible hacerlo de distintas formas, la más básica y sencilla es a través de un vector. Utilizando la función ‘c()’ e introduciendo los objetos a almacenar separándolos por comas entre sí. La característica fundamental de los vectores es que almacenan información de la misma clase. A continuación se muestran dos ejemplos con distinta clase cada uno. vector_numerico &lt;- c(1,2,3,4,5,6) print(vector_numerico) ## [1] 1 2 3 4 5 6 vector_caracter &lt;- c(&quot;este&quot;, &quot;es&quot;, &quot;un&quot;, &quot;vector&quot;, &quot;de&quot;, &quot;caracteres&quot;) print(vector_caracter) ## [1] &quot;este&quot; &quot;es&quot; &quot;un&quot; &quot;vector&quot; &quot;de&quot; ## [6] &quot;caracteres&quot; En caso de que se introduzcan objetos de diferentes clases, R convertirá la clase de los objetos de tal forma que todos puedan ser representados por la misma clase, por ejemplo: c(1,2,3,4,&quot;cinco&quot;) # Los números son representados como caracteres ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;cinco&quot; c(TRUE, 2, FALSE) # True y False se convierten en los números 1 y 0 respectivamente ## [1] 1 2 0 c(TRUE, F, 1, &quot;dos&quot;) # Todos los objetos son convertidos a caracteres ## [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;1&quot; &quot;dos&quot; Para acceder al i-ésimo elemento de un vector se usa un índice que determina su posición exacta dentro del vector. Este índice debe incluirse entre corchetes inmediatamente después del nombre del vector. Hay que tomar en cuenta que, a diferencia de otros lenguajes de programación, en R la numeración de los índices comienza desde 1, por lo que si se desea acceder al cuarto elemento o al conjunto de elementos 1,4,5,6, se deberá escribir de la siguiente forma: vector_caracter[4] ## [1] &quot;vector&quot; vector_caracter[c(1,4,5,6)] ## [1] &quot;este&quot; &quot;vector&quot; &quot;de&quot; &quot;caracteres&quot; En caso de que se desee almacenar elementos con diferente tipo de clase, es posible hacerlo mediante la implementación de “listas.” Las listas dividen en secciones los elementos de diferentes clases. Para poder acceder a dichas secciones, se usa el nombre de la sección o índice entre doble corchete. Por ejemplo: Mi_lista &lt;- list() Mi_lista[[1]] &lt;- c(1,2,3,4,5) Mi_lista[[&#39;Segunda entrada&#39;]] &lt;- c(T,T,F,T,F,F) Mi_lista[[3]] &lt;- c(&#39;Hay&#39;, 3, &#39;objetos almacenados&#39;) print(Mi_lista) ## [[1]] ## [1] 1 2 3 4 5 ## ## $`Segunda entrada` ## [1] TRUE TRUE FALSE TRUE FALSE FALSE ## ## [[3]] ## [1] &quot;Hay&quot; &quot;3&quot; &quot;objetos almacenados&quot; Para acceder a la j-ésima sección, se debe especificar entre doble corchete el índice o nombre de la sección deseada. Si se desea acceder al i-ésimo elemento de la j-ésima sección, deberá ser especificada la sección y posteriormente el i-ésimo elemnto a extraer. Mi_lista[[1]] # Extracción completa de la primera sección. ## [1] 1 2 3 4 5 Mi_lista[[1]][3] # Extracción del tercer elemento de la primera sección. ## [1] 3 Mi_lista[[2]][c(2,3,4)] # Extracción de los elemntos 2,3 y 4 de la segunda sección. ## [1] TRUE FALSE TRUE Mi_lista[[3]][3] ## [1] &quot;objetos almacenados&quot; Para almacenar grandes conjuntos de información conformados por distintos vectores, es común recurrir a los objetos de la clase ‘data.frame.’ La estructura de dichos objectos está conformada por dos dimensiones (renglones y columnas). Dicha estructura se usa principalmente para capturar diferentes características de sujetos o elementos, los renglones son las observaciones o los distintos sujetos y las columnas se usan para capturar cada una de las características del sujeto u observación. Esta estructura suele ser trabajada de dos formas principales, la primera es construyéndose desde dentro del código conforme se va generando la información, ó bien la segunda, leyendo datos de manera externa. El primer método requiere de la concatenación de 2 o más vectores de la misma dimensión. Los elementos a concatenar se pasan como parámetros de la función cbind.data.frame() ó rbind.data.frame(), dependiendo de si se desean concatenar como renglones o como columnas. A continuación se verá un ejemplo: vector1&lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;) vector2&lt;- c(1,2,3,4,5) vector3&lt;- c(T,F,T,F,T) dataframe1&lt;-cbind.data.frame(vector1,vector2,vector3) colnames(dataframe1)&lt;- c(&quot;Columna 1&quot;,&quot;Columna 2&quot;,&quot;Columna 3&quot;) dataframe1 ## Columna 1 Columna 2 Columna 3 ## 1 a 1 TRUE ## 2 b 2 FALSE ## 3 c 3 TRUE ## 4 d 4 FALSE ## 5 e 5 TRUE class(dataframe1) ## [1] &quot;data.frame&quot; dataframe2 &lt;-rbind.data.frame(vector1,vector2,vector3) colnames(dataframe2)&lt;-c(&quot;Columna 1&quot;,&quot;Columna 2&quot;,&quot;Columna 3&quot;, &quot;Columna 4&quot;,&quot;Columna 5&quot;) dataframe2 ## Columna 1 Columna 2 Columna 3 Columna 4 Columna 5 ## 1 a b c d e ## 2 1 2 3 4 5 ## 3 TRUE FALSE TRUE FALSE TRUE class(dataframe2) ## [1] &quot;data.frame&quot; "],["lectura-de-datos.html", "Capítulo 3 Lectura de datos 3.1 Lectura de datos 3.2 Bases de Datos", " Capítulo 3 Lectura de datos Usualmente, no creamos los datos desde la sesión de R, sino que a través de un archivo externo se realiza la lectura de datos escritos en un archivo. Los más comúnes son: La paquetería readr fue desarrollada recientemente para lidiar con la lectura de archivos grandes rápidamente. El paquete proporciona reemplazos para funciones como read.table(), read.csv() entre otras. Esta paquetería proporciona funciones que suelen ser mucho más rápidas que las funciones base que proporciona R. Ventajas de readr: Por lo general, son mucho más rápidos (~ 10x) que sus funciones equivalentes. Producen tibbles: No convierten vectores de caracteres en factores. No usan nombres de filas ni modifican los nombres de columnas. Reproducibilidad 3.1 Lectura de datos 3.1.1 Archivos csv A la hora de importar conjuntos de datos en R, uno de los formatos más habituales en los que hallamos información es en archivos separados por comas (comma separated values), cuya extensión suele ser .csv. En ellos encontramos múltiples líneas que recogen la tabla de interés, y en las cuales los valores aparecen, de manera consecutiva, separados por el carácter ,. Para importar este tipo de archivos en nuestra sesión de R, se utiliza la función read_csv(). Para acceder a su documentación utilizamos el comando ?read_csv. El único argumento que debemos de pasar a esta función de manera obligatoria, es file, el nombre o la ruta completa del archivo que pretendemos importar. library(readr) read_csv( file, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(&quot;&quot;, &quot;NA&quot;), quoted_na = TRUE, quote = &quot;\\&quot;&quot;, comment = &quot;&quot;) Algunas de las ventajas que utilizar read_csv() ofrece son: No convierte, automáticamente, las columnas con cadenas de caracteres a factores, como sí hacen por defecto las otras funciones base de R. Reconoce ocho clases diferentes de datos (enteros, lógicos, etc.), dejando el resto como cadenas de caracteres. Veamos un ejemplo: La base de datos llamada AmesHousing contiene un conjunto de datos con información de la Oficina del Tasador de Ames utilizada para calcular los valores tasados para las propiedades residenciales individuales vendidas en Ames, Iowa, de 2006 a 2010. FUENTES: Ames, Oficina del Tasador de Iowa. Pueden descargar los datos para la clase aquí base&lt;- read.csv(&quot;data/ames.csv&quot;) head(base, 2) ## MS_SubClass MS_Zoning Lot_Frontage ## 1 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 141 ## 2 One_Story_1946_and_Newer_All_Styles Residential_High_Density 80 ## Lot_Area Street Alley Lot_Shape Land_Contour Utilities ## 1 31770 Pave No_Alley_Access Slightly_Irregular Lvl AllPub ## 2 11622 Pave No_Alley_Access Regular Lvl AllPub ## Lot_Config Land_Slope Neighborhood Condition_1 Condition_2 Bldg_Type ## 1 Corner Gtl North_Ames Norm Norm OneFam ## 2 Inside Gtl North_Ames Feedr Norm OneFam ## House_Style Overall_Cond Year_Built Year_Remod_Add Roof_Style Roof_Matl ## 1 One_Story Average 1960 1960 Hip CompShg ## 2 One_Story Above_Average 1961 1961 Gable CompShg ## Exterior_1st Exterior_2nd Mas_Vnr_Type Mas_Vnr_Area Exter_Cond Foundation ## 1 BrkFace Plywood Stone 112 Typical CBlock ## 2 VinylSd VinylSd None 0 Typical CBlock ## Bsmt_Cond Bsmt_Exposure BsmtFin_Type_1 BsmtFin_SF_1 BsmtFin_Type_2 ## 1 Good Gd BLQ 2 Unf ## 2 Typical No Rec 6 LwQ ## BsmtFin_SF_2 Bsmt_Unf_SF Total_Bsmt_SF Heating Heating_QC Central_Air ## 1 0 441 1080 GasA Fair Y ## 2 144 270 882 GasA Typical Y ## Electrical First_Flr_SF Second_Flr_SF Gr_Liv_Area Bsmt_Full_Bath ## 1 SBrkr 1656 0 1656 1 ## 2 SBrkr 896 0 896 0 ## Bsmt_Half_Bath Full_Bath Half_Bath Bedroom_AbvGr Kitchen_AbvGr TotRms_AbvGrd ## 1 0 1 0 3 1 7 ## 2 0 1 0 2 1 5 ## Functional Fireplaces Garage_Type Garage_Finish Garage_Cars Garage_Area ## 1 Typ 2 Attchd Fin 2 528 ## 2 Typ 0 Attchd Unf 1 730 ## Garage_Cond Paved_Drive Wood_Deck_SF Open_Porch_SF Enclosed_Porch ## 1 Typical Partial_Pavement 210 62 0 ## 2 Typical Paved 140 0 0 ## Three_season_porch Screen_Porch Pool_Area Pool_QC Fence ## 1 0 0 0 No_Pool No_Fence ## 2 0 120 0 No_Pool Minimum_Privacy ## Misc_Feature Misc_Val Mo_Sold Year_Sold Sale_Type Sale_Condition Sale_Price ## 1 None 0 5 2010 WD Normal 215000 ## 2 None 0 6 2010 WD Normal 105000 ## Longitude Latitude ## 1 -93.61975 42.05403 ## 2 -93.61976 42.05301 tidy&lt;- read_csv(&quot;data/ames.csv&quot;) ## Rows: 2930 Columns: 74 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (40): MS_SubClass, MS_Zoning, Street, Alley, Lot_Shape, Land_Contour, Ut... ## dbl (34): Lot_Frontage, Lot_Area, Year_Built, Year_Remod_Add, Mas_Vnr_Area, ... ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. head(tidy, 2) ## # A tibble: 2 × 74 ## MS_SubClass MS_Zoning Lot_Frontage Lot_Area Street Alley Lot_Shape ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 One_Story_1946_… Residential_… 141 31770 Pave No_All… Slightly_… ## 2 One_Story_1946_… Residential_… 80 11622 Pave No_All… Regular ## # … with 67 more variables: Land_Contour &lt;chr&gt;, Utilities &lt;chr&gt;, ## # Lot_Config &lt;chr&gt;, Land_Slope &lt;chr&gt;, Neighborhood &lt;chr&gt;, Condition_1 &lt;chr&gt;, ## # Condition_2 &lt;chr&gt;, Bldg_Type &lt;chr&gt;, House_Style &lt;chr&gt;, Overall_Cond &lt;chr&gt;, ## # Year_Built &lt;dbl&gt;, Year_Remod_Add &lt;dbl&gt;, Roof_Style &lt;chr&gt;, Roof_Matl &lt;chr&gt;, ## # Exterior_1st &lt;chr&gt;, Exterior_2nd &lt;chr&gt;, Mas_Vnr_Type &lt;chr&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Cond &lt;chr&gt;, Foundation &lt;chr&gt;, Bsmt_Cond &lt;chr&gt;, ## # Bsmt_Exposure &lt;chr&gt;, BsmtFin_Type_1 &lt;chr&gt;, BsmtFin_SF_1 &lt;dbl&gt;, … ¿Y si el archivo que necesitamos leer esta en excel? 3.1.2 Archivos xls y xlsx La paquetería readxl facilita la obtención de datos tabulares de archivos de Excel. Admite tanto el formato .xls heredado como el formato .xlsx moderno basado en XML. Esta paqueteía pone a disposición las siguientes funciones: read_xlsx() lee un archivo con extensión xlsx. read_xlsx( path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = &quot;unique&quot; ) read_xls() lee un archivo con extensión xls. read_xls( path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = &quot;unique&quot; ) read_excel() determina si el archivo es de tipo xls o xlsx para después llamar a una de las fuciones mencionadas anteriormente. read_excel( path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = &quot;unique&quot; ) EJERCICIO: Leer archivo excel de la carpeta del curso 3.1.3 Archivos json Se utiliza la función fromJSON de la paquetería jsonlite library(jsonlite) base_json &lt;- jsonlite::fromJSON(&quot;data/ames.json&quot;) head(base_json, 2) ## MS_SubClass MS_Zoning Lot_Frontage ## 1 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 141 ## 2 One_Story_1946_and_Newer_All_Styles Residential_High_Density 80 ## Lot_Area Street Alley Lot_Shape Land_Contour Utilities ## 1 31770 Pave No_Alley_Access Slightly_Irregular Lvl AllPub ## 2 11622 Pave No_Alley_Access Regular Lvl AllPub ## Lot_Config Land_Slope Neighborhood Condition_1 Condition_2 Bldg_Type ## 1 Corner Gtl North_Ames Norm Norm OneFam ## 2 Inside Gtl North_Ames Feedr Norm OneFam ## House_Style Overall_Cond Year_Built Year_Remod_Add Roof_Style Roof_Matl ## 1 One_Story Average 1960 1960 Hip CompShg ## 2 One_Story Above_Average 1961 1961 Gable CompShg ## Exterior_1st Exterior_2nd Mas_Vnr_Type Mas_Vnr_Area Exter_Cond Foundation ## 1 BrkFace Plywood Stone 112 Typical CBlock ## 2 VinylSd VinylSd None 0 Typical CBlock ## Bsmt_Cond Bsmt_Exposure BsmtFin_Type_1 BsmtFin_SF_1 BsmtFin_Type_2 ## 1 Good Gd BLQ 2 Unf ## 2 Typical No Rec 6 LwQ ## BsmtFin_SF_2 Bsmt_Unf_SF Total_Bsmt_SF Heating Heating_QC Central_Air ## 1 0 441 1080 GasA Fair Y ## 2 144 270 882 GasA Typical Y ## Electrical First_Flr_SF Second_Flr_SF Gr_Liv_Area Bsmt_Full_Bath ## 1 SBrkr 1656 0 1656 1 ## 2 SBrkr 896 0 896 0 ## Bsmt_Half_Bath Full_Bath Half_Bath Bedroom_AbvGr Kitchen_AbvGr TotRms_AbvGrd ## 1 0 1 0 3 1 7 ## 2 0 1 0 2 1 5 ## Functional Fireplaces Garage_Type Garage_Finish Garage_Cars Garage_Area ## 1 Typ 2 Attchd Fin 2 528 ## 2 Typ 0 Attchd Unf 1 730 ## Garage_Cond Paved_Drive Wood_Deck_SF Open_Porch_SF Enclosed_Porch ## 1 Typical Partial_Pavement 210 62 0 ## 2 Typical Paved 140 0 0 ## Three_season_porch Screen_Porch Pool_Area Pool_QC Fence ## 1 0 0 0 No_Pool No_Fence ## 2 0 120 0 No_Pool Minimum_Privacy ## Misc_Feature Misc_Val Mo_Sold Year_Sold Sale_Type Sale_Condition Sale_Price ## 1 None 0 5 2010 WD Normal 215000 ## 2 None 0 6 2010 WD Normal 105000 ## Longitude Latitude ## 1 -93.6198 42.054 ## 2 -93.6198 42.053 3.2 Bases de Datos En muchos de los casos la información estará dentro de un Sistema Manejador de Bases de Datos, existen bibliotecas que nos permiten establecer las conexiones con ellas, algunos ejemplos son: ODBC DBI Un ejemplo con un SMBD como SQL Server: 3.2.1 Microsoft SQL Server Referencias Configuración de conexión: Se necesitan seis configuraciones para realizar una conexión: Controlador : consulte la sección Controladores para obtener más información Servidor : una ruta de red al servidor de la base de datos. Base de datos : el nombre de la base de datos. UID : el ID de red del usuario o la cuenta local del servidor PWD : la contraseña de la cuenta Puerto : debe establecerse en 1433 Para establecer la conexión con la base de datos: library(DBI) con &lt;- DBI::dbConnect( odbc::odbc(), Driver = &quot;[your driver&#39;s name]&quot;, Server = &quot;[your server&#39;s path]&quot;, Database = &quot;[your database&#39;s name]&quot;, UID = rstudioapi::askForPassword(&quot;Database user&quot;), PWD = rstudioapi::askForPassword(&quot;Database password&quot;), Port = 1433 ) Información sobre la base de datos: El odbcpaquete le brinda herramientas para explorar objetos y columnas en la base de datos. # Top level objects odbcListObjects(con) # Tables in a schema odbcListObjects(con, catalog = &quot;mydb&quot;, schema = &quot;dbo&quot;) # Columns in a table odbcListColumns(con, catalog = &quot;mydb&quot;, schema = &quot;dbo&quot;, table = &quot;cars&quot;) # Database structure odbcListObjectTypes(con) Consultas con SQL: Para consultas interactivas, utilice dbGetQuery() para enviar una consulta y obtener los resultados. Para obtener los resultados por separado, utilice dbSendQuery() y dbFetch(). El argumento n en dbFetch() se puede utilizar para obtener resultados parciales. # Return the results for an arbitrary query dbGetQuery(con, &quot;SELECT speed, dist FROM cars&quot;) # Fetch the first 100 records query &lt;- dbSendQuery(con, &quot;SELECT speed, dist FROM cars&quot;) dbFetch(query, n = 10) dbClearResult(query) Puedes usar los ejemplos anteriores para probar con diferentes consultas y bases de datos. Tengamos un ejemplo de manera local: remotes::install_version(&quot;RSQLite&quot;) library(dplyr) library(dbplyr) library(RSQLite) con &lt;- src_memdb() copy_to(con, storms, overwrite = T) tbl_storms &lt;- tbl(con, &quot;storms&quot;) tbl_storms ## # Source: table&lt;storms&gt; [?? x 13] ## # Database: sqlite 3.37.0 [:memory:] ## name year month day hour lat long status category wind pressure ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Amy 1975 6 27 0 27.5 -79 tropical d… -1 25 1013 ## 2 Amy 1975 6 27 6 28.5 -79 tropical d… -1 25 1013 ## 3 Amy 1975 6 27 12 29.5 -79 tropical d… -1 25 1013 ## 4 Amy 1975 6 27 18 30.5 -79 tropical d… -1 25 1013 ## 5 Amy 1975 6 28 0 31.5 -78.8 tropical d… -1 25 1012 ## 6 Amy 1975 6 28 6 32.4 -78.7 tropical d… -1 25 1012 ## 7 Amy 1975 6 28 12 33.3 -78 tropical d… -1 25 1011 ## 8 Amy 1975 6 28 18 34 -77 tropical d… -1 30 1006 ## 9 Amy 1975 6 29 0 34.4 -75.8 tropical s… 0 35 1004 ## 10 Amy 1975 6 29 6 34 -74.8 tropical s… 0 40 1002 ## # … with more rows, and 2 more variables: ts_diameter &lt;dbl&gt;, hu_diameter &lt;dbl&gt; "],["tidyverse.html", "Capítulo 4 Tidyverse 4.1 Consultas de datos", " Capítulo 4 Tidyverse 4.1 Consultas de datos Ahora que ya sabemos como cargar datos, aprenderemos como manipularlos con dplyr. El paquete dplyr proporciona un conjunto de funciones muy útiles para manipular data frames y así reducir el número de repeticiones, la probabilidad de cometer errores y el número de caracteres que hay que escribir. Como valor extra, podemos encontrar que la gramática de dplyr es más fácil de entender. Revisaremos algunas de sus funciones más usadas (verbos), así como el uso de pipes (%&gt;%) para combinarlas. select() filter() arrange() mutate() summarise() join() group_by() Primero tenemos que instalar y cargar la paquetería (parte de tidyverse): # install.packages(&quot;dplyr&quot;) library(dplyr) Usaremos el dataset iris que se encuentra en la paquetería datasets (el alumno puede hacer el ejercicio con la base AmesHousing) head(iris,10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa 4.1.1 select() Observamos que nuestros datos tienen 150 observaciones y 5 variables, con select() podemos seleccionar las variables que le indiquemos. select_ejemplo&lt;-iris %&gt;% select(Sepal.Length,Petal.Length,Species) head(select_ejemplo,10) ## Sepal.Length Petal.Length Species ## 1 5.1 1.4 setosa ## 2 4.9 1.4 setosa ## 3 4.7 1.3 setosa ## 4 4.6 1.5 setosa ## 5 5.0 1.4 setosa ## 6 5.4 1.7 setosa ## 7 4.6 1.4 setosa ## 8 5.0 1.5 setosa ## 9 4.4 1.4 setosa ## 10 4.9 1.5 setosa El operador pipe (%&gt;%) se usa para conectar múltiples acciones, en este caso solo le indicamos que de la base iris seleccionara 3 varibles y que guardara este nuevo data frame en la variable select_ejemplo. Con select() y contains podemos seleccionar varibles con alguna cadena de texto. select_ejemplo&lt;-iris %&gt;% select(contains(&quot;Sepal&quot;)) head(select_ejemplo,5) ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 De igual manera, con select(), ends_with y start_with() podemos seleccionar que inicien o terminen con alguna cadena de texto. select_ejemplo&lt;-iris %&gt;% select(starts_with(&quot;Sepal&quot;),ends_with(&quot;Length&quot;)) head(select_ejemplo,5) ## Sepal.Length Sepal.Width Petal.Length ## 1 5.1 3.5 1.4 ## 2 4.9 3.0 1.4 ## 3 4.7 3.2 1.3 ## 4 4.6 3.1 1.5 ## 5 5.0 3.6 1.4 Funciones útiles para select(): contains(): Selecciona variables cuyo nombre contiene la cadena de texto. ends_with(): Selecciona variables cuyo nombre termina con la cadena de caracteres. everything(): Selecciona todas las columnas. matches(): Selecciona las variables cuyos nombres coinciden con una expresión regular. num_range(): Selecciona las variables por posición. one_of(): Selecciona variables cuyos nombres están en un grupo de nombres. start_with(): Selecciona variables cuyos nombres empiezan con la cadena de caracteres. 4.1.2 filter() La función filter nos permite filtrar filas según una condición, primero notemos que la variable Species tiene tres categorías. table(iris$Species) ## ## setosa versicolor virginica ## 50 50 50 Ahora usaremos la función filter para quedarnos solo con las observaciones de la especie virginica. ejemplo_filter&lt;- iris %&gt;% filter(Species==&quot;virginica&quot;) head(ejemplo_filter,5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 6.3 3.3 6.0 2.5 virginica ## 2 5.8 2.7 5.1 1.9 virginica ## 3 7.1 3.0 5.9 2.1 virginica ## 4 6.3 2.9 5.6 1.8 virginica ## 5 6.5 3.0 5.8 2.2 virginica También se puede usar para filtrar variables numéricas: ejemplo_filter&lt;- iris %&gt;% filter(Sepal.Length&gt;5 &amp; Sepal.Width&gt;=3.5) head(ejemplo_filter,5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 5.4 3.9 1.7 0.4 setosa ## 3 5.4 3.7 1.5 0.2 setosa ## 4 5.8 4.0 1.2 0.2 setosa ## 5 5.7 4.4 1.5 0.4 setosa Notemos que en el ejemplo anterior usamos &amp;, que nos ayuda a filtrar por dos condiciones. También podemos usar | para filtrar por alguna de las dos condiciones. ejemplo_filter&lt;- iris %&gt;% filter(Sepal.Length&gt;5 | Sepal.Width&gt;=3.5) head(ejemplo_filter,5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 5.0 3.6 1.4 0.2 setosa ## 3 5.4 3.9 1.7 0.4 setosa ## 4 5.4 3.7 1.5 0.2 setosa ## 5 5.8 4.0 1.2 0.2 setosa Las condiciones pueden ser expresiones lógicas construidas mediante los operadores relacionales y lógicos: &lt; : Menor que &gt; : Mayor que = : Igual que &lt;= : Menor o igual que &gt;= : Mayor o igual que != : Diferente que %in% : Pertenece al conjunto is.na : Es NA !is.na : No es NA 4.1.3 arrange() La función arrange() se utiliza para ordenar las filas de un data frame de acuerdo a una o varias variables. Por defecto arrange() ordena las filas por orden ascendente: ejemplo_arrange&lt;- iris %&gt;% arrange(Sepal.Length) head(ejemplo_arrange,10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 4.3 3.0 1.1 0.1 setosa ## 2 4.4 2.9 1.4 0.2 setosa ## 3 4.4 3.0 1.3 0.2 setosa ## 4 4.4 3.2 1.3 0.2 setosa ## 5 4.5 2.3 1.3 0.3 setosa ## 6 4.6 3.1 1.5 0.2 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 4.6 3.6 1.0 0.2 setosa ## 9 4.6 3.2 1.4 0.2 setosa ## 10 4.7 3.2 1.3 0.2 setosa Si las queremos ordenar de forma ascendente lo haremos del siguiente modo: ejemplo_arrange&lt;- iris %&gt;% arrange(desc(Sepal.Length)) head(ejemplo_arrange,10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.9 3.8 6.4 2.0 virginica ## 2 7.7 3.8 6.7 2.2 virginica ## 3 7.7 2.6 6.9 2.3 virginica ## 4 7.7 2.8 6.7 2.0 virginica ## 5 7.7 3.0 6.1 2.3 virginica ## 6 7.6 3.0 6.6 2.1 virginica ## 7 7.4 2.8 6.1 1.9 virginica ## 8 7.3 2.9 6.3 1.8 virginica ## 9 7.2 3.6 6.1 2.5 virginica ## 10 7.2 3.2 6.0 1.8 virginica 4.1.4 mutate() Con la función mutate() podemos computar tranformaciones de variables en un data frame. A menudo, tendremos la necesidad de crear nuevas variables que se calculan a partir de variables existentes,mutate() nos proporciona una interface clara para realizar este tipo de operaciones. Por ejemplo haremos la suma de las variables Sepal.Lenght y Sepal.Width: ejemplo_mutate&lt;- iris %&gt;% select(Sepal.Length,Sepal.Width) %&gt;% mutate(Suma=Sepal.Length+Sepal.Width) head(ejemplo_mutate,5) ## Sepal.Length Sepal.Width Suma ## 1 5.1 3.5 8.6 ## 2 4.9 3.0 7.9 ## 3 4.7 3.2 7.9 ## 4 4.6 3.1 7.7 ## 5 5.0 3.6 8.6 Notemos que en el ejemplo anterior usamos dos pipes (%&gt;%), como habiamos mencionado se pueden usar los necesarios para combinar funciones. 4.1.5 summarise() La función summarise() funciona de forma análoga a la función mutate, excepto que en lugar de añadir nuevas columnas crea un nuevo data frame. Podemos usar el ejemplo anterior y calcular la media de la varible creada Suma: ejemplo_summarise&lt;- iris %&gt;% select(Sepal.Length,Sepal.Width) %&gt;% mutate(Suma=Sepal.Length+Sepal.Width) %&gt;% summarise(Media_Suma=mean(Suma)) ejemplo_summarise ## Media_Suma ## 1 8.900667 Solo fue necesario agregar un pipe, especificar el nombre de la varible creada y la operación a realizar. A continuación se muestran funciones que trabajando conjuntamente con la función summarise() facilitarán nuestro trabajo diario. Las primeras pertenecen al paquete base y las otras son del paquete dplyr. Todas ellas toman como argumento un vector y devuelven un único resultado: min(), max() : Valores max y min. mean() : Media. median() : Mediana. sum() : Suma de los valores. var(), sd() : Varianza y desviación estandar. first() : Primer valor en un vector. last() : El último valor en un vector n() : El número de valores en un vector. n_distinc() : El número de valores distintos en un vector. nth() : Extrar el valor que ocupa la posición n en un vector. Mas adelante veremos como combinar esta función con la función group_by. 4.1.6 group_by() La función group_by() agrupa un conjunto de filas seleccionado en un conjunto de filas de resumen de acuerdo con los valores de una o más columnas o expresiones. Usaremos el ejemplo anterior, primero creamos nuestra nueva variable Suma, despues agrupamos por especie y al final sacamos la media de la variable Suma pero esta vez, por la función group_by, nos regresara una media por cada grupo creado, es decir, nos regresara el promedio de la suma por especie. ejemplo_groupby&lt;- iris %&gt;% mutate(Suma=Sepal.Length+Sepal.Width) %&gt;% group_by(Species) %&gt;% summarise(Media_Suma=mean(Suma)) ejemplo_groupby ## # A tibble: 3 × 2 ## Species Media_Suma ## &lt;fct&gt; &lt;dbl&gt; ## 1 setosa 8.43 ## 2 versicolor 8.71 ## 3 virginica 9.56 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
